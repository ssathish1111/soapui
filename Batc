If you prefer to use JPA with entity classes (the standard JPA approach), here's how to implement it properly:

### 1. First, create the Entity class matching your table:

```java
import javax.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "CRM_ACT_EMAIL_REQUEST", schema = "ENS_RENSPET")
public class CrmActEmailRequest {
    
    @Id
    @Column(name = "ID")
    private Long id;
    
    @Column(name = "NOTIFICATION_ID")
    private Long notificationId;
    
    @Column(name = "ACCOUNT_ID", length = 32)
    private String accountId;
    
    @Column(name = "LANGUAGE_CODE", length = 2)
    private String languageCode;
    
    @Column(name = "BATCH_FILE_NAME", length = 128)
    private String batchFileName;
    
    @Column(name = "FILE_CORRELATION_ID")
    private Long fileCorrelationId;
    
    @Column(name = "CRM_ACT_EMAIL_REQ_FILENAME", length = 64)
    private String crmActEmailReqFilename;
    
    @Column(name = "SENT_TO_CRM")
    private Integer sentToCrm;
    
    @Column(name = "CREATED_ON")
    private LocalDateTime createdOn;
    
    @Column(name = "MODIFIED_ON")
    private LocalDateTime modifiedOn;
    
    @Column(name = "CREATED_BY", length = 32)
    private String createdBy;
    
    @Column(name = "IS_BUSINESS_TEMPLATE", length = 1)
    private String isBusinessTemplate;
    
    // Constructors
    public CrmActEmailRequest() {}
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public Long getNotificationId() { return notificationId; }
    public void setNotificationId(Long notificationId) { this.notificationId = notificationId; }
    
    // ... continue with all other getters/setters
}
```

### 2. Create a JPA Repository interface:

```java
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;

public interface CrmActEmailRequestRepository extends JpaRepository<CrmActEmailRequest, Long> {
    
    List<CrmActEmailRequest> findByBatchFileName(String batchFileName);
    
    @Transactional
    @Modifying
    @Query("UPDATE CrmActEmailRequest c SET c.sentToCrm = 1, c.modifiedOn = CURRENT_TIMESTAMP " +
           "WHERE c.notificationId IN :notificationIds")
    void markAsSent(@Param("notificationIds") List<Long> notificationIds);
    
    @Transactional
    default void saveAllInBatch(List<CrmActEmailRequest> entities) {
        saveAll(entities);
    }
}
```

### 3. Create a Service class:

```java
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class CrmActEmailService {
    
    private final CrmActEmailRequestRepository repository;
    
    public CrmActEmailService(CrmActEmailRequestRepository repository) {
        this.repository = repository;
    }
    
    @Transactional
    public void processBatch(List<CrmActEmailRequest> requests) {
        repository.saveAllInBatch(requests);
    }
    
    public List<CrmActEmailRequest> getByBatchFileName(String batchFileName) {
        return repository.findByBatchFileName(batchFileName);
    }
    
    @Transactional
    public void markNotificationsAsSent(List<Long> notificationIds) {
        repository.markAsSent(notificationIds);
    }
    
    public CrmActEmailRequest createFromMap(Map<String, Object> data) {
        CrmActEmailRequest entity = new CrmActEmailRequest();
        entity.setId((Long) data.get("ID"));
        entity.setNotificationId((Long) data.get("NOTIFICATION_ID"));
        entity.setAccountId((String) data.get("ACCOUNT_ID"));
        entity.setLanguageCode((String) data.get("LANGUAGE_CODE"));
        entity.setBatchFileName((String) data.get("BATCH_FILE_NAME"));
        entity.setFileCorrelationId((Long) data.get("FILE_CORRELATION_ID"));
        entity.setCrmActEmailReqFilename((String) data.get("CRM_ACT_EMAIL_REQ_FILENAME"));
        entity.setSentToCrm((Integer) data.get("SENT_TO_CRM"));
        entity.setIsBusinessTemplate((String) data.get("IS_BUSINESS_TEMPLATE"));
        return entity;
    }
}
```

### 4. Update your Processor to use the Entity:

```java
import com.fasterxml.jackson.databind.JsonNode;
import org.springframework.stereotype.Component;
import java.io.IOException;
import java.util.*;

@Component
public class NotificationProcessor {
    private final CrmActEmailService emailService;
    private final int batchSize;
    
    public NotificationProcessor(CrmActEmailService emailService, int batchSize) {
        this.emailService = emailService;
        this.batchSize = batchSize;
    }

    public void processNotifications(BatchContextJSON context) throws IOException {
        // ... (same JSON parsing code as before until mapNotificationNode)
        
        List<CrmActEmailRequest> notifications = new ArrayList<>();
        
        while (parser.nextToken() != JsonToken.END_ARRAY) {
            if (parser.currentToken() == JsonToken.START_OBJECT) {
                JsonNode node = objectMapper.readTree(parser);
                Map<String, Object> notificationMap = mapNotificationToMap(context, node);
                CrmActEmailRequest entity = emailService.createFromMap(notificationMap);
                notifications.add(entity);

                if (notifications.size() >= batchSize) {
                    emailService.processBatch(notifications);
                    notifications.clear();
                }
            }
        }

        if (!notifications.isEmpty()) {
            emailService.processBatch(notifications);
        }
    }

    private Map<String, Object> mapNotificationToMap(BatchContextJSON context, JsonNode node) {
        Map<String, Object> notification = new HashMap<>();
        
        // Required fields
        notification.put("ID", generateId());
        notification.put("NOTIFICATION_ID", getNodeLong(node, "notificationId"));
        notification.put("ACCOUNT_ID", getNodeText(node, "accountId"));
        notification.put("LANGUAGE_CODE", getNodeText(node, "languageCode"));
        notification.put("BATCH_FILE_NAME", context.getBatchFileName());
        notification.put("FILE_CORRELATION_ID", context.getFileCorrelationId());
        
        // Optional fields with defaults
        notification.put("CRM_ACT_EMAIL_REQ_FILENAME", 
            getNodeText(node, "filename", "default_filename"));
        notification.put("SENT_TO_CRM", 0);
        notification.put("IS_BUSINESS_TEMPLATE", 
            getNodeText(node, "isBusinessTemplate", "N"));
        
        return notification;
    }
    
    // ... helper methods remain the same
}
```

### 5. Configuration (application.properties):

```properties
# JPA/Hibernate
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# Datasource
spring.datasource.url=jdbc:oracle:thin:@//host:port/service
spring.datasource.username=username
spring.datasource.password=password
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

# JPA
spring.jpa.database-platform=org.hibernate.dialect.Oracle12cDialect
```

### Key Benefits of This Approach:

1. **Type Safety**: Compile-time checking of entity fields
2. **JPA Features**: Automatic dirty checking, caching, lazy loading
3. **Repository Pattern**: Clean separation of data access logic
4. **Transaction Management**: Built-in with Spring
5. **Batch Processing**: Efficient database operations
6. **Schema Validation**: Hibernate validates against actual database schema

### Usage Example:

```java
// Get all notifications for a batch
List<CrmActEmailRequest> notifications = emailService.getByBatchFileName("batch_001");

// Process and mark as sent
emailService.markNotificationsAsSent(
    notifications.stream()
        .map(CrmActEmailRequest::getNotificationId)
        .collect(Collectors.toList())
);
```

This is the standard JPA approach that provides the best combination of type safety, maintainability, and performance. The entity class serves as the single source of truth for your database schema.
