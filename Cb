Here's the updated code to use the explicit service-specific configurations:

1. Update application.yml with Explicit Configurations for All Services

```yaml
application:
  resilience:
    services:
      RENDER_SERVICE:
        failureRateThreshold: 50
        waitDurationInOpenStateSeconds: 60
        slidingWindowSize: 10
        slidingWindowType: COUNT_BASED
        permittedCallsInHalfOpenState: 5
        automaticTransitionFromOpenToHalfOpenEnabled: true
        retryMaxAttempts: 3
        retryWaitDurationSeconds: 1
        retryEnabled: true
      
      PDF_GENERATOR_SERVICE:
        failureRateThreshold: 60
        waitDurationInOpenStateSeconds: 120
        slidingWindowSize: 5
        slidingWindowType: COUNT_BASED
        permittedCallsInHalfOpenState: 3
        automaticTransitionFromOpenToHalfOpenEnabled: false
        retryMaxAttempts: 2
        retryWaitDurationSeconds: 2
        retryEnabled: true
      
      PUBLISHER_SERVICE:
        failureRateThreshold: 40
        waitDurationInOpenStateSeconds: 30
        slidingWindowSize: 20
        slidingWindowType: COUNT_BASED
        permittedCallsInHalfOpenState: 4
        automaticTransitionFromOpenToHalfOpenEnabled: true
        retryMaxAttempts: 3
        retryWaitDurationSeconds: 1
        retryEnabled: true
      
      SWIP_SERVER:
        failureRateThreshold: 70
        waitDurationInOpenStateSeconds: 90
        slidingWindowSize: 15
        slidingWindowType: COUNT_BASED
        permittedCallsInHalfOpenState: 5
        automaticTransitionFromOpenToHalfOpenEnabled: true
        retryMaxAttempts: 4
        retryWaitDurationSeconds: 1
        retryEnabled: false
      
      # Add configurations for DAL_SERVICE, SNSC_SERVICE, IML_SERVICE, SCHEDULER_SERVICE similarly
```

2. Update ResilienceConfigProperties Class

```java
package com.rogers.api.config;

import com.rogers.api.model.ServiceResilienceConfig;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

@Configuration
@ConfigurationProperties(prefix = "application.resilience")
@Data
public class ResilienceConfigProperties {
    private Map<String, ServiceResilienceConfig> services = new HashMap<>();
    
    // Get config for specific service - throws exception if not configured
    public ServiceResilienceConfig getConfigForService(String serviceName) {
        ServiceResilienceConfig config = services.get(serviceName);
        if (config == null) {
            throw new IllegalStateException(
                String.format("No resilience configuration found for service: %s", serviceName)
            );
        }
        return config;
    }
}
```

3. Update ServiceResilienceConfig Model Class

```java
package com.rogers.api.model;

import lombok.Data;

@Data
public class ServiceResilienceConfig {
    private float failureRateThreshold;
    private long waitDurationInOpenStateSeconds;
    private int slidingWindowSize;
    private String slidingWindowType;
    private int permittedCallsInHalfOpenState;
    private boolean automaticTransitionFromOpenToHalfOpenEnabled;
    
    private int retryMaxAttempts;
    private long retryWaitDurationSeconds;
    private boolean retryEnabled;
}
```

4. Create a Configuration Validator

```java
@Component
public class ResilienceConfigValidator implements ApplicationRunner {
    
    private final ResilienceConfigProperties resilienceConfigProperties;
    
    public ResilienceConfigValidator(ResilienceConfigProperties resilienceConfigProperties) {
        this.resilienceConfigProperties = resilienceConfigProperties;
    }
    
    @Override
    public void run(ApplicationArguments args) {
        log.info("Validating resilience configurations...");
        
        // Check that all services in ApiServiceEnum have configurations
        for (ApiServiceEnum service : ApiServiceEnum.values()) {
            String serviceName = service.getServiceName();
            ServiceResilienceConfig config = resilienceConfigProperties.getServices().get(serviceName);
            
            if (config == null) {
                throw new IllegalStateException(
                    String.format("Missing resilience configuration for service: %s", serviceName)
                );
            }
            
            // Validate configuration values
            validateConfig(serviceName, config);
            
            log.info("✓ Service [{}] configured with: failureRateThreshold={}, retryEnabled={}", 
                serviceName, config.getFailureRateThreshold(), config.isRetryEnabled());
        }
        
        log.info("All {} services have valid resilience configurations", ApiServiceEnum.values().length);
    }
    
    private void validateConfig(String serviceName, ServiceResilienceConfig config) {
        if (config.getFailureRateThreshold() <= 0 || config.getFailureRateThreshold() > 100) {
            throw new IllegalStateException(
                String.format("Invalid failureRateThreshold for service %s: %s", 
                    serviceName, config.getFailureRateThreshold())
            );
        }
        
        if (config.getWaitDurationInOpenStateSeconds() <= 0) {
            throw new IllegalStateException(
                String.format("Invalid waitDurationInOpenStateSeconds for service %s: %s", 
                    serviceName, config.getWaitDurationInOpenStateSeconds())
            );
        }
        
        // Add more validations as needed
    }
}
```

5. Update Resilience Configuration Beans

```java
@Configuration
public class ResilienceConfig {
    
    private final ResilienceConfigProperties resilienceConfigProperties;
    
    public ResilienceConfig(ResilienceConfigProperties resilienceConfigProperties) {
        this.resilienceConfigProperties = resilienceConfigProperties;
    }
    
    @Bean
    public CircuitBreakerRegistry circuitBreakerRegistry() {
        log.info("Initializing CircuitBreakerRegistry with service-specific configurations...");
        
        // Create a map of configurations for all services
        Map<String, CircuitBreakerConfig> configs = new HashMap<>();
        
        for (ApiServiceEnum service : ApiServiceEnum.values()) {
            String serviceName = service.getServiceName();
            ServiceResilienceConfig serviceConfig = resilienceConfigProperties.getConfigForService(serviceName);
            
            CircuitBreakerConfig cbConfig = CircuitBreakerConfig.custom()
                .failureRateThreshold(serviceConfig.getFailureRateThreshold())
                .waitDurationInOpenState(Duration.ofSeconds(serviceConfig.getWaitDurationInOpenStateSeconds()))
                .slidingWindowSize(serviceConfig.getSlidingWindowSize())
                .slidingWindowType(CircuitBreakerConfig.SlidingWindowType.valueOf(serviceConfig.getSlidingWindowType()))
                .permittedNumberOfCallsInHalfOpenState(serviceConfig.getPermittedCallsInHalfOpenState())
                .automaticTransitionFromOpenToHalfOpenEnabled(serviceConfig.isAutomaticTransitionFromOpenToHalfOpenEnabled())
                .recordException(e -> e instanceof WebClientResponseException)
                .build();
            
            configs.put(serviceName, cbConfig);
        }
        
        // Create registry with all configurations
        CircuitBreakerRegistry registry = CircuitBreakerRegistry.of(configs);
        
        // Register event listeners
        registry.getEventPublisher()
            .onEntryAdded(event -> registerStateListener(event.getAddedEntry()));
        
        return registry;
    }
    
    private void registerStateListener(CircuitBreaker circuitBreaker) {
        circuitBreaker.getEventPublisher()
            .onStateTransition(event -> {
                log.info("CircuitBreaker [{}] transitioned from {} to {}", 
                    circuitBreaker.getName(), event.getFromState(), event.getToState());
            });
    }
    
    @Bean
    public RetryRegistry retryRegistry() {
        log.info("Initializing RetryRegistry with service-specific configurations...");
        
        // Create a map of configurations for all services
        Map<String, RetryConfig> configs = new HashMap<>();
        
        for (ApiServiceEnum service : ApiServiceEnum.values()) {
            String serviceName = service.getServiceName();
            ServiceResilienceConfig serviceConfig = resilienceConfigProperties.getConfigForService(serviceName);
            
            if (serviceConfig.isRetryEnabled()) {
                RetryConfig retryConfig = RetryConfig.custom()
                    .maxAttempts(serviceConfig.getRetryMaxAttempts())
                    .waitDuration(Duration.ofSeconds(serviceConfig.getRetryWaitDurationSeconds()))
                    .ignoreExceptions(APIFailureException.class)
                    .build();
                
                configs.put(serviceName, retryConfig);
            }
        }
        
        return RetryRegistry.of(configs);
    }
}
```

6. Update ResilientServiceExecutor

```java
@Component
public class ResilientServiceExecutor {
    
    private final CircuitBreakerRegistry circuitBreakerRegistry;
    private final RetryRegistry retryRegistry;
    private final ResilienceConfigProperties configProperties;
    
    public ResilientServiceExecutor(CircuitBreakerRegistry circuitBreakerRegistry,
                                   RetryRegistry retryRegistry,
                                   ResilienceConfigProperties configProperties) {
        this.circuitBreakerRegistry = circuitBreakerRegistry;
        this.retryRegistry = retryRegistry;
        this.configProperties = configProperties;
    }
    
    public <T> T executeWithResilience(ApiServiceEnum service, Supplier<T> supplier) {
        String serviceName = service.getServiceName();
        
        // Get service-specific config to check if retry is enabled
        ServiceResilienceConfig serviceConfig = configProperties.getConfigForService(serviceName);
        
        // Get circuit breaker for this service
        CircuitBreaker cb = circuitBreakerRegistry.circuitBreaker(serviceName);
        
        Supplier<T> decoratedSupplier;
        
        if (serviceConfig.isRetryEnabled()) {
            Retry retry = retryRegistry.retry(serviceName);
            decoratedSupplier = CircuitBreaker.decorateSupplier(
                cb, 
                Retry.decorateSupplier(retry, supplier)
            );
        } else {
            decoratedSupplier = CircuitBreaker.decorateSupplier(cb, supplier);
        }
        
        return decoratedSupplier.get();
    }
    
    public CircuitBreaker.State getServiceState(String serviceName) {
        try {
            CircuitBreaker cb = circuitBreakerRegistry.circuitBreaker(serviceName);
            return cb.getState();
        } catch (Exception e) {
            log.warn("Could not get state for service: {}", serviceName);
            return CircuitBreaker.State.CLOSED;
        }
    }
    
    public Map<String, Object> getServiceConfigInfo(String serviceName) {
        ServiceResilienceConfig config = configProperties.getConfigForService(serviceName);
        Map<String, Object> info = new HashMap<>();
        
        info.put("failureRateThreshold", config.getFailureRateThreshold());
        info.put("waitDurationInOpenStateSeconds", config.getWaitDurationInOpenStateSeconds());
        info.put("slidingWindowSize", config.getSlidingWindowSize());
        info.put("retryEnabled", config.isRetryEnabled());
        info.put("retryMaxAttempts", config.getRetryMaxAttempts());
        
        return info;
    }
}
```

7. Create a Configuration Endpoint

```java
@RestController
@RequestMapping("/api/resilience/config")
public class ResilienceConfigController {
    
    private final ResilienceConfigProperties configProperties;
    private final ResilientServiceExecutor executor;
    
    public ResilienceConfigController(ResilienceConfigProperties configProperties,
                                     ResilientServiceExecutor executor) {
        this.configProperties = configProperties;
        this.executor = executor;
    }
    
    @GetMapping("/services")
    public Map<String, Object> getAllServiceConfigs() {
        Map<String, Object> result = new HashMap<>();
        
        for (ApiServiceEnum service : ApiServiceEnum.values()) {
            String serviceName = service.getServiceName();
            
            Map<String, Object> serviceInfo = new HashMap<>();
            serviceInfo.put("config", configProperties.getConfigForService(serviceName));
            serviceInfo.put("currentState", executor.getServiceState(serviceName));
            
            result.put(serviceName, serviceInfo);
        }
        
        return result;
    }
    
    @GetMapping("/services/{serviceName}")
    public Map<String, Object> getServiceConfig(@PathVariable String serviceName) {
        ServiceResilienceConfig config = configProperties.getConfigForService(serviceName);
        Map<String, Object> result = new HashMap<>();
        
        result.put("config", config);
        result.put("currentState", executor.getServiceState(serviceName));
        
        return result;
    }
}
```

Key Features of This Implementation:

1. Explicit Configurations: Every service must have its configuration defined in the YAML file
2. Validation at Startup: Application fails fast if any service is missing configuration
3. Service-Specific Settings: Each service can have completely different circuit breaker and retry settings
4. No Defaults: No fallback to default configurations - everything is explicit
5. Easy to Monitor: Endpoints to view all service configurations and current states
6. Type-Safe Configuration: Using Spring's @ConfigurationProperties for type-safe configuration binding
7. Runtime Configuration Access: Easy to access service-specific configurations at runtime

This approach ensures you have full control over each service's resilience behavior and can easily see what's configured for each service.
Option 3 Implementation: Custom Setters with @JsonProperty

Here's the complete implementation using @JsonProperty to map kebab-case YAML properties to camelCase Java fields:

1. Updated application.yml

```yaml
application:
  graceful:
    timeout: ${GRACEFUL_SHUTDOWN_TIMEOUT} # sec
    wait:
      interval: ${GRACEFUL_SHUTDOWN_WAIT_INTERVAL} # sec
  
  resilience:
    circuit-breaker:
      services:
        RENDER_SERVICE:
          failure-rate-threshold: 50
          wait-duration-in-open-state: 60
          sliding-window-size: 10
          sliding-window-type: COUNT_BASED
          permitted-calls-in-half-open-state: 5
          auto-open-to-half-open-enabled: true
          retry-max-attempts: 3
          retry-wait-duration-seconds: 1
          retry-enabled: true
        
        PDF_GENERATOR_SERVICE:
          failure-rate-threshold: 50
          wait-duration-in-open-state: 60
          sliding-window-size: 10
          sliding-window-type: COUNT_BASED
          permitted-calls-in-half-open-state: 5
          auto-open-to-half-open-enabled: true
          retry-max-attempts: 3
          retry-wait-duration-seconds: 1
          retry-enabled: true
        
        PUBLISHER_SERVICE:
          failure-rate-threshold: 60
          wait-duration-in-open-state: 90
          sliding-window-size: 20
          sliding-window-type: COUNT_BASED
          permitted-calls-in-half-open-state: 4
          auto-open-to-half-open-enabled: true
          retry-max-attempts: 3
          retry-wait-duration-seconds: 1
          retry-enabled: true
        
        SWIP_SERVER:
          failure-rate-threshold: 70
          wait-duration-in-open-state: 120
          sliding-window-size: 25
          sliding-window-type: COUNT_BASED
          permitted-calls-in-half-open-state: 2
          auto-open-to-half-open-enabled: true
          retry-max-attempts: 1
          retry-wait-duration-seconds: 0
          retry-enabled: false
        
        DAL_SERVICE:
          failure-rate-threshold: 55
          wait-duration-in-open-state: 75
          sliding-window-size: 12
          sliding-window-type: COUNT_BASED
          permitted-calls-in-half-open-state: 5
          auto-open-to-half-open-enabled: true
          retry-max-attempts: 4
          retry-wait-duration-seconds: 3
          retry-enabled: true
        
        SNSC_SERVICE:
          failure-rate-threshold: 45
          wait-duration-in-open-state: 60
          sliding-window-size: 18
          sliding-window-type: COUNT_BASED
          permitted-calls-in-half-open-state: 3
          auto-open-to-half-open-enabled: false
          retry-max-attempts: 2
          retry-wait-duration-seconds: 2
          retry-enabled: true
        
        IML_SERVICE:
          failure-rate-threshold: 65
          wait-duration-in-open-state: 100
          sliding-window-size: 8
          sliding-window-type: COUNT_BASED
          permitted-calls-in-half-open-state: 4
          auto-open-to-half-open-enabled: true
          retry-max-attempts: 3
          retry-wait-duration-seconds: 1
          retry-enabled: true
        
        SCHEDULER_SERVICE:
          failure-rate-threshold: 35
          wait-duration-in-open-state: 50
          sliding-window-size: 30
          sliding-window-type: COUNT_BASED
          permitted-calls-in-half-open-state: 6
          auto-open-to-half-open-enabled: true
          retry-max-attempts: 5
          retry-wait-duration-seconds: 1
          retry-enabled: true
```

2. Updated ResilienceService.java with Custom Setters

```java
package com.rogers.api.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

@Data
public class ResilienceService {
    
    // Keep your original field names as they are
    private float failureRateThreshold;
    private long waitDurationInOpenStatesseconds;
    private int slidingWindowSize;
    private String slidingWindowType;
    private int permittedCallsInHalfOpenState;
    private boolean autoOpenToHalfOpenEnabled;
    private int retryMaxAttempts;
    private long retryWaitDurationSeconds;
    private boolean retryEnabled;
    
    // Custom setters with @JsonProperty for kebab-case YAML properties
    
    @JsonProperty("failure-rate-threshold")
    public void setFailureRateThreshold(float failureRateThreshold) {
        this.failureRateThreshold = failureRateThreshold;
    }
    
    @JsonProperty("wait-duration-in-open-state")
    public void setWaitDurationInOpenState(long waitDurationInOpenState) {
        this.waitDurationInOpenStatesseconds = waitDurationInOpenState;
    }
    
    @JsonProperty("sliding-window-size")
    public void setSlidingWindowSize(int slidingWindowSize) {
        this.slidingWindowSize = slidingWindowSize;
    }
    
    @JsonProperty("sliding-window-type")
    public void setSlidingWindowType(String slidingWindowType) {
        this.slidingWindowType = slidingWindowType;
    }
    
    @JsonProperty("permitted-calls-in-half-open-state")
    public void setPermittedCallsInHalfOpenState(int permittedCallsInHalfOpenState) {
        this.permittedCallsInHalfOpenState = permittedCallsInHalfOpenState;
    }
    
    @JsonProperty("auto-open-to-half-open-enabled")
    public void setAutoOpenToHalfOpenEnabled(boolean autoOpenToHalfOpenEnabled) {
        this.autoOpenToHalfOpenEnabled = autoOpenToHalfOpenEnabled;
    }
    
    @JsonProperty("retry-max-attempts")
    public void setRetryMaxAttempts(int retryMaxAttempts) {
        this.retryMaxAttempts = retryMaxAttempts;
    }
    
    @JsonProperty("retry-wait-duration-seconds")
    public void setRetryWaitDurationSeconds(long retryWaitDurationSeconds) {
        this.retryWaitDurationSeconds = retryWaitDurationSeconds;
    }
    
    @JsonProperty("retry-enabled")
    public void setRetryEnabled(boolean retryEnabled) {
        this.retryEnabled = retryEnabled;
    }
}
```

3. Updated ResilienceConfigProperties.java

```java
package com.rogers.api.config;

import com.rogers.api.model.ResilienceService;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

@Configuration
@ConfigurationProperties(prefix = "application.resilience.circuit-breaker")
@Data
public class ResilienceConfigProperties {
    
    private Map<String, ResilienceService> services = new HashMap<>();

    public ResilienceService getConfigForService(String serviceName) {
        ResilienceService config = services.get(serviceName);
        if (config == null) {
            throw new IllegalArgumentException(
                String.format("No resilience configuration found for service: %s", serviceName)
            );
        }
        return config;
    }
    
    public boolean hasServiceConfig(String serviceName) {
        return services.containsKey(serviceName);
    }
    
    public void validateAllServicesConfigured() {
        for (ApiServiceEnum service : ApiServiceEnum.values()) {
            String serviceName = service.getServiceName();
            if (!hasServiceConfig(serviceName)) {
                throw new IllegalStateException(
                    String.format("Missing resilience configuration for service: %s", serviceName)
                );
            }
        }
    }
}
```

4. Add Jackson Dependency to pom.xml

```xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.15.2</version> <!-- Use the version compatible with your Spring Boot -->
</dependency>
```

5. Circuit Breaker Configuration

```java
@Configuration
public class ResilienceConfig {
    
    private final ResilienceConfigProperties configProperties;
    
    public ResilienceConfig(ResilienceConfigProperties configProperties) {
        this.configProperties = configProperties;
    }
    
    @Bean
    public CircuitBreakerRegistry circuitBreakerRegistry() {
        log.info("Initializing CircuitBreakerRegistry...");
        
        Map<String, CircuitBreakerConfig> serviceConfigs = new HashMap<>();
        
        for (ApiServiceEnum service : ApiServiceEnum.values()) {
            String serviceName = service.getServiceName();
            ResilienceService serviceConfig = configProperties.getConfigForService(serviceName);
            
            // Build circuit breaker config for this service
            CircuitBreakerConfig cbConfig = CircuitBreakerConfig.custom()
                .failureRateThreshold(serviceConfig.getFailureRateThreshold())
                .waitDurationInOpenState(Duration.ofSeconds(serviceConfig.getWaitDurationInOpenStatesseconds()))
                .slidingWindowSize(serviceConfig.getSlidingWindowSize())
                .slidingWindowType(CircuitBreakerConfig.SlidingWindowType.valueOf(
                    serviceConfig.getSlidingWindowType().toUpperCase()))
                .permittedNumberOfCallsInHalfOpenState(serviceConfig.getPermittedCallsInHalfOpenState())
                .automaticTransitionFromOpenToHalfOpenEnabled(serviceConfig.isAutoOpenToHalfOpenEnabled())
                .recordException(e -> e instanceof WebClientResponseException)
                .build();
            
            serviceConfigs.put(serviceName, cbConfig);
            
            log.debug("Configured circuit breaker for {}: failureRateThreshold={}, waitDuration={}s",
                serviceName, 
                serviceConfig.getFailureRateThreshold(),
                serviceConfig.getWaitDurationInOpenStatesseconds());
        }
        
        CircuitBreakerRegistry registry = CircuitBreakerRegistry.of(serviceConfigs);
        
        // Register event listeners
        registry.getEventPublisher()
            .onEntryAdded(event -> registerStateListener(event.getAddedEntry()));
        
        log.info("CircuitBreakerRegistry initialized with {} services", serviceConfigs.size());
        return registry;
    }
    
    private void registerStateListener(CircuitBreaker circuitBreaker) {
        circuitBreaker.getEventPublisher()
            .onStateTransition(event -> {
                log.info("CircuitBreaker [{}] transitioned from {} to {}", 
                    circuitBreaker.getName(), event.getFromState(), event.getToState());
            });
    }
    
    @Bean
    public RetryRegistry retryRegistry() {
        log.info("Initializing RetryRegistry...");
        
        Map<String, RetryConfig> serviceConfigs = new HashMap<>();
        
        for (ApiServiceEnum service : ApiServiceEnum.values()) {
            String serviceName = service.getServiceName();
            ResilienceService serviceConfig = configProperties.getConfigForService(serviceName);
            
            if (serviceConfig.isRetryEnabled()) {
                RetryConfig retryConfig = RetryConfig.custom()
                    .maxAttempts(serviceConfig.getRetryMaxAttempts())
                    .waitDuration(Duration.ofSeconds(serviceConfig.getRetryWaitDurationSeconds()))
                    .ignoreExceptions(APIFailureException.class)
                    .build();
                
                serviceConfigs.put(serviceName, retryConfig);
                
                log.debug("Configured retry for {}: maxAttempts={}, waitDuration={}s",
                    serviceName,
                    serviceConfig.getRetryMaxAttempts(),
                    serviceConfig.getRetryWaitDurationSeconds());
            }
        }
        
        log.info("RetryRegistry initialized with {} services", serviceConfigs.size());
        return RetryRegistry.of(serviceConfigs);
    }
}
```

6. ResilientServiceExecutor

```java
@Component
public class ResilientServiceExecutor {
    
    private final CircuitBreakerRegistry circuitBreakerRegistry;
    private final RetryRegistry retryRegistry;
    private final ResilienceConfigProperties configProperties;
    
    private final Map<String, CircuitBreaker> circuitBreakerCache = new ConcurrentHashMap<>();
    private final Map<String, Retry> retryCache = new ConcurrentHashMap<>();
    
    public ResilientServiceExecutor(CircuitBreakerRegistry circuitBreakerRegistry,
                                   RetryRegistry retryRegistry,
                                   ResilienceConfigProperties configProperties) {
        this.circuitBreakerRegistry = circuitBreakerRegistry;
        this.retryRegistry = retryRegistry;
        this.configProperties = configProperties;
    }
    
    public <T> T executeWithResilience(ApiServiceEnum service, Supplier<T> supplier) {
        String serviceName = service.getServiceName();
        
        // Get service-specific configuration
        ResilienceService serviceConfig = configProperties.getConfigForService(serviceName);
        
        // Get or create circuit breaker
        CircuitBreaker cb = circuitBreakerCache.computeIfAbsent(
            serviceName,
            name -> circuitBreakerRegistry.circuitBreaker(name)
        );
        
        Supplier<T> decoratedSupplier;
        
        if (serviceConfig.isRetryEnabled()) {
            // Get or create retry
            Retry retry = retryCache.computeIfAbsent(
                serviceName,
                name -> retryRegistry.retry(name)
            );
            
            decoratedSupplier = CircuitBreaker.decorateSupplier(
                cb, 
                Retry.decorateSupplier(retry, supplier)
            );
        } else {
            decoratedSupplier = CircuitBreaker.decorateSupplier(cb, supplier);
        }
        
        return decoratedSupplier.get();
    }
    
    public CircuitBreaker.State getServiceState(String serviceName) {
        try {
            CircuitBreaker cb = circuitBreakerCache.get(serviceName);
            if (cb == null) {
                cb = circuitBreakerRegistry.circuitBreaker(serviceName);
                circuitBreakerCache.put(serviceName, cb);
            }
            return cb.getState();
        } catch (Exception e) {
            log.warn("Could not get state for service: {}", serviceName, e);
            return CircuitBreaker.State.CLOSED;
        }
    }
    
    public Map<String, Object> getServiceConfigInfo(String serviceName) {
        ResilienceService config = configProperties.getConfigForService(serviceName);
        Map<String, Object> info = new HashMap<>();
        
        info.put("failureRateThreshold", config.getFailureRateThreshold());
        info.put("waitDurationInOpenStatesseconds", config.getWaitDurationInOpenStatesseconds());
        info.put("slidingWindowSize", config.getSlidingWindowSize());
        info.put("slidingWindowType", config.getSlidingWindowType());
        info.put("permittedCallsInHalfOpenState", config.getPermittedCallsInHalfOpenState());
        info.put("autoOpenToHalfOpenEnabled", config.isAutoOpenToHalfOpenEnabled());
        info.put("retryMaxAttempts", config.getRetryMaxAttempts());
        info.put("retryWaitDurationSeconds", config.getRetryWaitDurationSeconds());
        info.put("retryEnabled", config.isRetryEnabled());
        
        return info;
    }
}
```

7. Configuration Validator

```java
@Component
public class ResilienceConfigValidator implements ApplicationRunner {
    
    private final ResilienceConfigProperties configProperties;
    
    public ResilienceConfigValidator(ResilienceConfigProperties configProperties) {
        this.configProperties = configProperties;
    }
    
    @Override
    public void run(ApplicationArguments args) {
        log.info("=== Resilience Configuration Validation ===");
        
        try {
            configProperties.validateAllServicesConfigured();
            
            // Validate each service configuration
            for (ApiServiceEnum service : ApiServiceEnum.values()) {
                String serviceName = service.getServiceName();
                ResilienceService config = configProperties.getConfigForService(serviceName);
                
                validateServiceConfig(serviceName, config);
                
                log.info("✓ Service [{}]:", serviceName);
                log.info("    Circuit Breaker:");
                log.info("      - failureRateThreshold: {}", config.getFailureRateThreshold());
                log.info("      - waitDurationInOpenStatesseconds: {}", config.getWaitDurationInOpenStatesseconds());
                log.info("      - slidingWindowSize: {}", config.getSlidingWindowSize());
                log.info("      - slidingWindowType: {}", config.getSlidingWindowType());
                log.info("      - permittedCallsInHalfOpenState: {}", config.getPermittedCallsInHalfOpenState());
                log.info("      - autoOpenToHalfOpenEnabled: {}", config.isAutoOpenToHalfOpenEnabled());
                log.info("    Retry:");
                log.info("      - retryEnabled: {}", config.isRetryEnabled());
                log.info("      - retryMaxAttempts: {}", config.getRetryMaxAttempts());
                log.info("      - retryWaitDurationSeconds: {}", config.getRetryWaitDurationSeconds());
            }
            
            log.info("✓ All {} services have valid resilience configurations", 
                ApiServiceEnum.values().length);
            
        } catch (Exception e) {
            log.error("✗ Resilience configuration validation failed", e);
            throw e;
        }
    }
    
    private void validateServiceConfig(String serviceName, ResilienceService config) {
        if (config.getFailureRateThreshold() <= 0 || config.getFailureRateThreshold() > 100) {
            throw new IllegalStateException(
                String.format("Invalid failureRateThreshold for service %s: %s", 
                    serviceName, config.getFailureRateThreshold())
            );
        }
        
        if (config.getWaitDurationInOpenStatesseconds() <= 0) {
            throw new IllegalStateException(
                String.format("Invalid waitDurationInOpenStatesseconds for service %s: %s", 
                    serviceName, config.getWaitDurationInOpenStatesseconds())
            );
        }
        
        if (config.getSlidingWindowSize() <= 0) {
            throw new IllegalStateException(
                String.format("Invalid slidingWindowSize for service %s: %s", 
                    serviceName, config.getSlidingWindowSize())
            );
        }
        
        if (!config.getSlidingWindowType().equals("COUNT_BASED") && 
            !config.getSlidingWindowType().equals("TIME_BASED")) {
            throw new IllegalStateException(
                String.format("Invalid slidingWindowType for service %s: %s. Must be COUNT_BASED or TIME_BASED", 
                    serviceName, config.getSlidingWindowType())
            );
        }
    }
}
```

8. Debug Endpoint to Verify Mapping

```java
@RestController
@RequestMapping("/api/debug/resilience")
public class ResilienceDebugController {
    
    private final ResilienceConfigProperties configProperties;
    private final ResilientServiceExecutor executor;
    
    public ResilienceDebugController(ResilienceConfigProperties configProperties,
                                   ResilientServiceExecutor executor) {
        this.configProperties = configProperties;
        this.executor = executor;
    }
    
    @GetMapping("/config/mapping")
    public Map<String, Object> showConfigMapping() {
        Map<String, Object> result = new HashMap<>();
        
        for (ApiServiceEnum service : ApiServiceEnum.values()) {
            String serviceName = service.getServiceName();
            
            Map<String, Object> serviceInfo = new HashMap<>();
            serviceInfo.put("config", configProperties.getConfigForService(serviceName));
            serviceInfo.put("currentState", executor.getServiceState(serviceName));
            
            result.put(serviceName, serviceInfo);
        }
        
        return result;
    }
    
    @GetMapping(


I understand. You only want to load and configure services that are explicitly defined in the YAML configuration, not all services in the ApiServiceEnum. Here's the updated implementation:

1. Updated ResilienceConfigProperties.java

```java
package com.rogers.api.config;

import com.rogers.api.model.ResilienceService;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import javax.annotation.PostConstruct;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@Configuration
@ConfigurationProperties(prefix = "application.resilience.circuit-breaker")
@Data
public class ResilienceConfigProperties {
    
    // Only services defined in YAML will be loaded here
    private Map<String, ResilienceService> services = new HashMap<>();

    @PostConstruct
    public void init() {
        log.info("Loaded resilience configurations for {} services: {}", 
            services.size(), services.keySet());
    }

    public ResilienceService getConfigForService(String serviceName) {
        ResilienceService config = services.get(serviceName);
        if (config == null) {
            throw new IllegalArgumentException(
                String.format("No resilience configuration found for service: %s", serviceName)
            );
        }
        return config;
    }
    
    public boolean hasServiceConfig(String serviceName) {
        return services.containsKey(serviceName);
    }
    
    public Set<String> getConfiguredServiceNames() {
        return services.keySet();
    }
}
```

2. Updated Circuit Breaker Configuration

```java
@Configuration
@Slf4j
public class ResilienceConfig {
    
    private final ResilienceConfigProperties configProperties;
    
    public ResilienceConfig(ResilienceConfigProperties configProperties) {
        this.configProperties = configProperties;
    }
    
    @Bean
    public CircuitBreakerRegistry circuitBreakerRegistry() {
        log.info("Initializing CircuitBreakerRegistry...");
        
        Map<String, CircuitBreakerConfig> serviceConfigs = new HashMap<>();
        
        // Only configure services that are defined in YAML
        for (Map.Entry<String, ResilienceService> entry : configProperties.getServices().entrySet()) {
            String serviceName = entry.getKey();
            ResilienceService serviceConfig = entry.getValue();
            
            try {
                CircuitBreakerConfig cbConfig = CircuitBreakerConfig.custom()
                    .failureRateThreshold(serviceConfig.getFailureRateThreshold())
                    .waitDurationInOpenState(Duration.ofSeconds(serviceConfig.getWaitDurationInOpenStatesseconds()))
                    .slidingWindowSize(serviceConfig.getSlidingWindowSize())
                    .slidingWindowType(CircuitBreakerConfig.SlidingWindowType.valueOf(
                        serviceConfig.getSlidingWindowType().toUpperCase()))
                    .permittedNumberOfCallsInHalfOpenState(serviceConfig.getPermittedCallsInHalfOpenState())
                    .automaticTransitionFromOpenToHalfOpenEnabled(serviceConfig.isAutoOpenToHalfOpenEnabled())
                    .recordException(e -> e instanceof WebClientResponseException)
                    .build();
                
                serviceConfigs.put(serviceName, cbConfig);
                
                log.info("Configured circuit breaker for {}: failureRateThreshold={}, waitDuration={}s, slidingWindowSize={}",
                    serviceName, 
                    serviceConfig.getFailureRateThreshold(),
                    serviceConfig.getWaitDurationInOpenStatesseconds(),
                    serviceConfig.getSlidingWindowSize());
                
            } catch (Exception e) {
                log.error("Failed to configure circuit breaker for service: {}", serviceName, e);
                throw new IllegalStateException(
                    String.format("Invalid circuit breaker configuration for service %s: %s", 
                        serviceName, e.getMessage()), e);
            }
        }
        
        if (serviceConfigs.isEmpty()) {
            log.warn("No circuit breaker configurations found. Circuit breaker functionality will be disabled.");
        } else {
            log.info("CircuitBreakerRegistry initialized with {} service(s): {}", 
                serviceConfigs.size(), serviceConfigs.keySet());
        }
        
        CircuitBreakerRegistry registry = CircuitBreakerRegistry.of(serviceConfigs);
        
        // Register event listeners only if we have configurations
        if (!serviceConfigs.isEmpty()) {
            registry.getEventPublisher()
                .onEntryAdded(event -> registerStateListener(event.getAddedEntry()));
        }
        
        return registry;
    }
    
    @Bean
    public RetryRegistry retryRegistry() {
        log.info("Initializing RetryRegistry...");
        
        Map<String, RetryConfig> serviceConfigs = new HashMap<>();
        
        // Only configure retries for services that have retry enabled in YAML
        for (Map.Entry<String, ResilienceService> entry : configProperties.getServices().entrySet()) {
            String serviceName = entry.getKey();
            ResilienceService serviceConfig = entry.getValue();
            
            if (serviceConfig.isRetryEnabled()) {
                try {
                    RetryConfig retryConfig = RetryConfig.custom()
                        .maxAttempts(serviceConfig.getRetryMaxAttempts())
                        .waitDuration(Duration.ofSeconds(serviceConfig.getRetryWaitDurationSeconds()))
                        .ignoreExceptions(APIFailureException.class)
                        .build();
                    
                    serviceConfigs.put(serviceName, retryConfig);
                    
                    log.info("Configured retry for {}: maxAttempts={}, waitDuration={}s",
                        serviceName,
                        serviceConfig.getRetryMaxAttempts(),
                        serviceConfig.getRetryWaitDurationSeconds());
                    
                } catch (Exception e) {
                    log.error("Failed to configure retry for service: {}", serviceName, e);
                    throw new IllegalStateException(
                        String.format("Invalid retry configuration for service %s: %s", 
                            serviceName, e.getMessage()), e);
                }
            }
        }
        
        if (serviceConfigs.isEmpty()) {
            log.warn("No retry configurations found. Retry functionality will be disabled.");
        } else {
            log.info("RetryRegistry initialized with {} service(s): {}", 
                serviceConfigs.size(), serviceConfigs.keySet());
        }
        
        return RetryRegistry.of(serviceConfigs);
    }
    
    private void registerStateListener(CircuitBreaker circuitBreaker) {
        circuitBreaker.getEventPublisher()
            .onStateTransition(event -> {
                log.info("CircuitBreaker [{}] transitioned from {} to {}", 
                    circuitBreaker.getName(), event.getFromState(), event.getToState());
            });
    }
}
```

3. Updated ResilientServiceExecutor

```java
@Component
@Slf4j
public class ResilientServiceExecutor {
    
    private final CircuitBreakerRegistry circuitBreakerRegistry;
    private final RetryRegistry retryRegistry;
    private final ResilienceConfigProperties configProperties;
    
    private final Map<String, CircuitBreaker> circuitBreakerCache = new ConcurrentHashMap<>();
    private final Map<String, Retry> retryCache = new ConcurrentHashMap<>();
    
    public ResilientServiceExecutor(CircuitBreakerRegistry circuitBreakerRegistry,
                                   RetryRegistry retryRegistry,
                                   ResilienceConfigProperties configProperties) {
        this.circuitBreakerRegistry = circuitBreakerRegistry;
        this.retryRegistry = retryRegistry;
        this.configProperties = configProperties;
        
        log.info("ResilientServiceExecutor initialized for {} configured service(s)", 
            configProperties.getServices().size());
    }
    
    public <T> T executeWithResilience(String serviceName, Supplier<T> supplier) {
        // Check if service is configured
        if (!configProperties.hasServiceConfig(serviceName)) {
            log.warn("Service {} is not configured for resilience. Executing without circuit breaker or retry.", 
                serviceName);
            return supplier.get();
        }
        
        // Get service-specific configuration
        ResilienceService serviceConfig = configProperties.getConfigForService(serviceName);
        
        // Get or create circuit breaker
        CircuitBreaker cb = circuitBreakerCache.computeIfAbsent(
            serviceName,
            name -> {
                try {
                    return circuitBreakerRegistry.circuitBreaker(name);
                } catch (Exception e) {
                    log.error("Failed to get circuit breaker for service: {}", serviceName, e);
                    throw new ServiceConfigurationException(
                        String.format("Circuit breaker not available for service: %s", serviceName), e);
                }
            }
        );
        
        Supplier<T> decoratedSupplier;
        
        if (serviceConfig.isRetryEnabled()) {
            // Get or create retry
            Retry retry = retryCache.computeIfAbsent(
                serviceName,
                name -> {
                    try {
                        return retryRegistry.retry(name);
                    } catch (Exception e) {
                        log.error("Failed to get retry for service: {}", serviceName, e);
                        throw new ServiceConfigurationException(
                            String.format("Retry not available for service: %s", serviceName), e);
                    }
                }
            );
            
            decoratedSupplier = CircuitBreaker.decorateSupplier(
                cb, 
                Retry.decorateSupplier(retry, supplier)
            );
        } else {
            decoratedSupplier = CircuitBreaker.decorateSupplier(cb, supplier);
        }
        
        return decoratedSupplier.get();
    }
    
    public <T> T executeWithResilience(ApiServiceEnum service, Supplier<T> supplier) {
        return executeWithResilience(service.getServiceName(), supplier);
    }
    
    public CircuitBreaker.State getServiceState(String serviceName) {
        if (!configProperties.hasServiceConfig(serviceName)) {
            log.debug("Service {} is not configured for resilience", serviceName);
            return CircuitBreaker.State.CLOSED;
        }
        
        try {
            CircuitBreaker cb = circuitBreakerCache.get(serviceName);
            if (cb == null) {
                cb = circuitBreakerRegistry.circuitBreaker(serviceName);
                circuitBreakerCache.put(serviceName, cb);
            }
            return cb.getState();
        } catch (Exception e) {
            log.warn("Could not get state for service: {}", serviceName, e);
            return CircuitBreaker.State.CLOSED;
        }
    }
    
    public boolean isServiceConfigured(String serviceName) {
        return configProperties.hasServiceConfig(serviceName);
    }
    
    public Map<String, Object> getServiceConfigInfo(String serviceName) {
        if (!configProperties.hasServiceConfig(serviceName)) {
            throw new IllegalArgumentException(
                String.format("Service %s is not configured for resilience", serviceName)
            );
        }
        
        ResilienceService config = configProperties.getConfigForService(serviceName);
        Map<String, Object> info = new HashMap<>();
        
        info.put("failureRateThreshold", config.getFailureRateThreshold());
        info.put("waitDurationInOpenStatesseconds", config.getWaitDurationInOpenStatesseconds());
        info.put("slidingWindowSize", config.getSlidingWindowSize());
        info.put("slidingWindowType", config.getSlidingWindowType());
        info.put("permittedCallsInHalfOpenState", config.getPermittedCallsInHalfOpenState());
        info.put("autoOpenToHalfOpenEnabled", config.isAutoOpenToHalfOpenEnabled());
        info.put("retryMaxAttempts", config.getRetryMaxAttempts());
        info.put("retryWaitDurationSeconds", config.getRetryWaitDurationSeconds());
        info.put("retryEnabled", config.isRetryEnabled());
        
        // Add current state
        info.put("currentState", getServiceState(serviceName));
        
        return info;
    }
    
    public Map<String, Object> getAllConfiguredServicesInfo() {
        Map<String, Object> result = new HashMap<>();
        
        for (String serviceName : configProperties.getConfiguredServiceNames()) {
            result.put(serviceName, getServiceConfigInfo(serviceName));
        }
        
        return result;
    }
}
```

4. Service Configuration Exception

```java
public class ServiceConfigurationException extends RuntimeException {
    
    public ServiceConfigurationException(String message) {
        super(message);
    }
    
    public ServiceConfigurationException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

5. Configuration Validator (Optional - Only Validates Configured Services)

```java
@Component
@Slf4j
public class ResilienceConfigValidator implements ApplicationRunner {
    
    private final ResilienceConfigProperties configProperties;
    
    public ResilienceConfigValidator(ResilienceConfigProperties configProperties) {
        this.configProperties = configProperties;
    }
    
    @Override
    public void run(ApplicationArguments args) {
        log.info("=== Resilience Configuration Validation ===");
        
        if (configProperties.getServices().isEmpty()) {
            log.warn("No resilience configurations found in application.yml");
            return;
        }
        
        log.info("Validating {} configured service(s)...", configProperties.getServices().size());
        
        for (Map.Entry<String, ResilienceService> entry : configProperties.getServices().entrySet()) {
            String serviceName = entry.getKey();
            ResilienceService config = entry.getValue();
            
            try {
                validateServiceConfig(serviceName, config);
                log.info("✓ Service [{}]: CB(failureRate={}, windowSize={}), Retry(enabled={}, maxAttempts={})",
                    serviceName,
                    config.getFailureRateThreshold(),
                    config.getSlidingWindowSize(),
                    config.isRetryEnabled(),
                    config.getRetryMaxAttempts()
                );
            } catch (Exception e) {
                log.error("✗ Invalid configuration for service [{}]: {}", serviceName, e.getMessage());
                throw e;
            }
        }
        
        log.info("✓ All {} configured service(s) have valid resilience configurations", 
            configProperties.getServices().size());
    }
    
    private void validateServiceConfig(String serviceName, ResilienceService config) {
        if (config.getFailureRateThreshold() <= 0 || config.getFailureRateThreshold() > 100) {
            throw new IllegalStateException(
                String.format("Invalid failureRateThreshold: %s. Must be between 0 and 100", 
                    config.getFailureRateThreshold())
            );
        }
        
        if (config.getWaitDurationInOpenStatesseconds() <= 0) {
            throw new IllegalStateException(
                String.format("Invalid waitDurationInOpenStatesseconds: %s. Must be positive", 
                    config.getWaitDurationInOpenStatesseconds())
            );
        }
        
        if (config.getSlidingWindowSize() <= 0) {
            throw new IllegalStateException(
                String.format("Invalid slidingWindowSize: %s. Must be positive", 
                    config.getSlidingWindowSize())
            );
        }
        
        if (!config.getSlidingWindowType().equals("COUNT_BASED") && 
            !config.getSlidingWindowType().equals("TIME_BASED")) {
            throw new IllegalStateException(
                String.format("Invalid slidingWindowType: %s. Must be COUNT_BASED or TIME_BASED", 
                    config.getSlidingWindowType())
            );
        }
        
        if (config.getPermittedCallsInHalfOpenState() <= 0) {
            throw new IllegalStateException(
                String.format("Invalid permittedCallsInHalfOpenState: %s. Must be positive", 
                    config.getPermittedCallsInHalfOpenState())
            );
        }
        
        if (config.isRetryEnabled()) {
            if (config.getRetryMaxAttempts() <= 0) {
                throw new IllegalStateException(
                    String.format("Invalid retryMaxAttempts: %s. Must be positive when retry is enabled", 
                        config.getRetryMaxAttempts())
                );
            }
            
            if (config.getRetryWaitDurationSeconds() < 0) {
                throw new IllegalStateException(
                    String.format("Invalid retryWaitDurationSeconds: %s. Must be non-negative", 
                        config.getRetryWaitDurationSeconds())
                );
            }
        }
    }
}
```

6. Health/Info Endpoint

```java
@RestController
@RequestMapping("/api/resilience")
@Slf4j
public class ResilienceInfoController {
    
    private final ResilientServiceExecutor executor;
    
    public ResilienceInfoController(ResilientServiceExecutor executor) {
        this.executor = executor;
    }
    
    @GetMapping("/services")
    public Map<String, Object> getConfiguredServices() {
        return executor.getAllConfiguredServicesInfo();
    }
    
    @GetMapping("/services/{serviceName}")
    public ResponseEntity<?> getServiceInfo(@PathVariable String serviceName) {
        if (!executor.isServiceConfigured(serviceName)) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(Map.of(
                    "error", "Service not configured",
                    "message", String.format("Service '%s' is not configured for resilience", serviceName),
                    "configuredServices", executor.getAllConfiguredServicesInfo().keySet()
                ));
        }
        
        return ResponseEntity.ok(executor.getServiceConfigInfo(serviceName));
    }
    
    @GetMapping("/services/{serviceName}/health")
    public ResponseEntity<?> getServiceHealth(@PathVariable String serviceName) {
        if (!executor.isServiceConfigured(serviceName)) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(Map.of(
                    "service", serviceName,
                    "configured", false,
                    "message", "Service is not configured for resilience monitoring"
                ));
        }
        
        CircuitBreaker.State state = executor.getServiceState(serviceName);
        boolean isHealthy = state != CircuitBreaker.State.OPEN;
        
        return ResponseEntity.ok(Map.of(
            "service", serviceName,
            "configured", true,
            "state", state.name(),
            "healthy", isHealthy,
            "timestamp", Instant.now().toString()
        ));
    }
}
```

7. Usage Example in Common Utility

```java
@Service
@Slf4j
public class CommonServiceUtil {
    
    private final ResilientServiceExecutor resilientExecutor;
    
    public CommonServiceUtil(ResilientServiceExecutor resilientExecutor) {
        this.resilientExecutor = resilientExecutor;
    }
    
    public String callServiceWithResilience(String serviceNa

protected <T> T executeWithCB(NotificationContext ctx, ApiServiceEnum apiService, Supplier<T> supplier) {
    String serviceName = apiService.getServiceName();
    try {
        ResilienceService serviceConfig = resilienceConfigParameters.getConfigForService(serviceName);
        
        // Log the configuration being retrieved
        log.debug("Retrieving CircuitBreaker for service: {}", serviceName);
        
        CircuitBreaker cb = circuitBreakerRegistry.circuitBreaker(serviceName);
        
        // Log the CircuitBreaker instance details
        logCircuitBreakerDetails(cb, serviceName, serviceConfig);
        
        // Rest of the code...
    } catch (Exception e) {
        // Error handling
    }
}

private void logCircuitBreakerDetails(CircuitBreaker cb, String serviceName, ResilienceService serviceConfig) {
    // Check if we got the right configuration
    Optional<CircuitBreakerConfig> config = circuitBreakerRegistry.getConfiguration(serviceName);
    
    if (config.isPresent()) {
        CircuitBreakerConfig actualConfig = config.get();
        log.info("CircuitBreaker for {} using configuration: failureRateThreshold={}, waitDuration={}s, slidingWindowSize={}",
            serviceName,
            actualConfig.getFailureRateThreshold(),
            actualConfig.getWaitDurationInOpenState().getSeconds(),
            actualConfig.getSlidingWindowSize()
        );
        
        // Compare with expected values from your config
        log.info("Expected config from properties: failureRateThreshold={}, waitDuration={}s",
            serviceConfig.getFailureRateThreshold(),
            serviceConfig.getWaitDurationInOpenState()
        );
    } else {
        log.warn("No specific configuration found for service: {}, using default", serviceName);
    }
}
