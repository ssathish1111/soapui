I'll refactor the code to use jSMPP 2.3.11 library with support for SubmitMulti, and improve the session/connection management. Here's the updated implementation:

```java
import org.jsmpp.bean.*;
import org.jsmpp.session.*;
import org.jsmpp.extra.*;
import org.jsmpp.session.connection.ConnectionFactory;
import org.jsmpp.session.connection.socket.SocketConnectionFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import lombok.extern.slf4j.Slf4j;

import java.io.File;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import javax.annotation.PreDestroy;

@Slf4j
public class SmppConnection {
    private final SMPPSession session;
    private final SmppSessionConfiguration config;
    private final int unbindTimeoutMs;
    private final ConnectionFactory connectionFactory;
    private volatile boolean isBound = false;

    public SmppConnection(SmppSessionConfiguration config, int unbindTimeoutMs) {
        this.config = config;
        this.unbindTimeoutMs = unbindTimeoutMs;
        this.connectionFactory = new SocketConnectionFactory();
        this.session = new SMPPSession(connectionFactory);
        
        // Configure session listeners
        session.setMessageReceiverListener(new MessageReceiverListenerImpl());
        session.addSessionStateListener(new SessionStateListenerImpl());
    }

    public void open() throws Exception {
        if (isHealthy()) return;
        
        try {
            session.connectAndBind(
                config.getHost(),
                config.getPort(),
                new BindParameter(
                    BindType.BIND_TRX,
                    config.getSystemId(),
                    config.getPassword(),
                    config.getSystemType(),
                    TypeOfNumber.UNKNOWN,
                    NumberingPlanIndicator.UNKNOWN,
                    null
                ),
                config.getBindTimeoutMs()
            );
            isBound = true;
            log.info("SMPP session bound: {}:{}", config.getHost(), config.getPort());
        } catch (Exception e) {
            isBound = false;
            throw new Exception("Failed to bind SMPP session to " + config.getHost() + ":" + config.getPort(), e);
        }
    }

    public void close() {
        if (session != null && isBound) {
            try {
                session.unbindAndClose(unbindTimeoutMs);
                log.info("SMPP session closed: {}:{}", config.getHost(), config.getPort());
            } catch (Exception e) {
                log.warn("Error closing SMPP session", e);
            } finally {
                isBound = false;
            }
        }
    }

    public boolean isHealthy() {
        return session != null && isBound && session.getSessionState().isBound();
    }

    public SubmitSmResp sendSingle(SubmitSm submit, long timeoutMs, SshTunnelManager tunnelManager) throws Exception {
        boolean didRetry = false;
        Exception lastException = null;

        do {
            try {
                if (!isHealthy()) throw new IllegalStateException("SMPP session not healthy");
                return session.submitShortMessage(
                    submit.getServiceType(),
                    submit.getSourceAddrTon(),
                    submit.getSourceAddrNpi(),
                    submit.getSourceAddr(),
                    submit.getDestAddrTon(),
                    submit.getDestAddrNpi(),
                    submit.getDestAddress(),
                    submit.getEsmClass(),
                    submit.getProtocolId(),
                    submit.getPriorityFlag(),
                    submit.getScheduleDeliveryTime(),
                    submit.getValidityPeriod(),
                    submit.getRegisteredDelivery(),
                    submit.getReplaceIfPresentFlag(),
                    submit.getDataCoding(),
                    submit.getSmDefaultMsgId(),
                    submit.getShortMessage(),
                    timeoutMs
                );
            } catch (Exception ex) {
                lastException = ex;
                close();
                
                if (!didRetry) {
                    didRetry = true;
                    tunnelManager.ensureUp();
                    open();
                } else {
                    throw lastException;
                }
            }
        } while (didRetry);
        
        throw new IllegalStateException("Unreachable: send() logic failed unexpectedly");
    }

    // SubmitMulti support
    public SubmitMultiResp sendMultiple(SubmitMulti submitMulti, long timeoutMs, SshTunnelManager tunnelManager) throws Exception {
        boolean didRetry = false;
        Exception lastException = null;

        do {
            try {
                if (!isHealthy()) throw new IllegalStateException("SMPP session not healthy");
                
                // Convert to jSMPP SubmitMulti format
                DestinationAddress[] destinations = submitMulti.getDestAddresses().stream()
                    .map(addr -> new DestinationAddress(
                        new Address(addr.getTon(), addr.getNpi(), addr.getAddress())
                    ))
                    .toArray(DestinationAddress[]::new);
                
                return session.submitMultiple(
                    submitMulti.getServiceType(),
                    submitMulti.getSourceAddrTon(),
                    submitMulti.getSourceAddrNpi(),
                    submitMulti.getSourceAddr(),
                    destinations,
                    submitMulti.getEsmClass(),
                    submitMulti.getProtocolId(),
                    submitMulti.getPriorityFlag(),
                    submitMulti.getScheduleDeliveryTime(),
                    submitMulti.getValidityPeriod(),
                    submitMulti.getRegisteredDelivery(),
                    submitMulti.getReplaceIfPresentFlag(),
                    submitMulti.getDataCoding(),
                    submitMulti.getSmDefaultMsgId(),
                    submitMulti.getShortMessage(),
                    timeoutMs
                );
            } catch (Exception ex) {
                lastException = ex;
                close();
                
                if (!didRetry) {
                    didRetry = true;
                    tunnelManager.ensureUp();
                    open();
                } else {
                    throw lastException;
                }
            }
        } while (didRetry);
        
        throw new IllegalStateException("Unreachable: sendMultiple() logic failed unexpectedly");
    }

    public void enquireLink() {
        if (isHealthy()) {
            try {
                session.enquireLink(new EnquireLink(), 1000);
            } catch (Exception e) {
                log.error("EnquireLink failed: {}", e.getMessage());
                if (e instanceof ResponseTimeoutException || e.getMessage().contains("Not bound")) {
                    isBound = false;
                }
            }
        }
    }

    // Session state listener
    private class SessionStateListenerImpl implements SessionStateListener {
        @Override
        public void onStateChange(SessionState newState, SessionState oldState, Object source) {
            log.debug("Session state changed from {} to {}", oldState, newState);
            if (!newState.isBound()) {
                isBound = false;
            }
        }
    }

    // Message receiver listener (if needed for receiving)
    private class MessageReceiverListenerImpl implements MessageReceiverListener {
        @Override
        public void onAcceptDeliverSm(DeliverSm deliverSm) throws ProcessRequestException {
            // Handle incoming messages if needed
        }

        @Override
        public DataSmResult onAcceptDataSm(DataSm dataSm, Session source) throws ProcessRequestException {
            return null; // Return appropriate response if needed
        }
    }
}

// Enhanced SmppConnectionPool with SubmitMulti support
@Slf4j
public class SmppConnectionPool {
    private final String serverName;
    private final BlockingQueue<SmppConnection> pool;
    private final PoolFactory factory;
    private final SmppConfigParameters config;
    private final ScheduledExecutorService keepAliveScheduler;

    public SmppConnectionPool(PoolFactory factory, int maxSize, String serverName, 
                             SmppConfigParameters config) throws Exception {
        this.pool = new LinkedBlockingQueue<>(maxSize);
        this.serverName = serverName;
        this.factory = factory;
        this.config = config;
        this.keepAliveScheduler = Executors.newSingleThreadScheduledExecutor();

        for (int i = 0; i < maxSize; i++) {
            SmppConnection conn = factory.create();
            conn.open();
            pool.offer(conn);
        }
        startKeepAliveTask();
    }

    private void startKeepAliveTask() {
        keepAliveScheduler.scheduleAtFixedRate(() -> {
            log.debug("SMPP keepalive task running for server: {}", serverName);
            for (SmppConnection conn : pool) {
                try {
                    if (conn.isHealthy()) {
                        conn.enquireLink();
                    }
                } catch (Exception e) {
                    log.error("Error during SMPP keepalive enquireLink", e);
                }
            }
        }, 30, 30, TimeUnit.SECONDS); // Every 30 seconds
    }

    public SmppConnection borrow(long timeout) throws InterruptedException {
        SmppConnection conn = pool.poll(timeout, TimeUnit.MILLISECONDS);
        if (conn == null) {
            throw new RuntimeException("All SMPP connections for server " + serverName + " are busy");
        }
        
        if (!conn.isHealthy()) {
            conn.close();
            try {
                conn = factory.create();
                conn.open();
            } catch (Exception e) {
                throw new RuntimeException("Failed to recreate SMPP connection for server " + serverName, e);
            }
        }
        return conn;
    }

    public void release(SmppConnection conn, SshTunnelManager tunnelManager) {
        if (conn.isHealthy()) {
            pool.offer(conn);
        } else {
            try {
                conn.close();
                tunnelManager.ensureUp();
                SmppConnection newConn = factory.create();
                newConn.open();
                pool.offer(newConn);
            } catch (Exception e) {
                log.error("Failed to replace broken SMPP connection", e);
            }
        }
    }

    public void shutdown() {
        keepAliveScheduler.shutdown();
        for (SmppConnection conn : pool) {
            conn.close();
        }
        pool.clear();
    }

    public boolean isHealthy() {
        for (SmppConnection conn : pool) {
            if (!conn.isHealthy()) return false;
        }
        return true;
    }
}

// Updated SmppMessageSender with SubmitMulti support
@Slf4j
@Service
public class SmppMessageSender {
    private final SshTunnelManager tunnelManager;
    private final SmppPoolGroup poolGroup;
    private final SmppConfigParameters config;

    public SmppMessageSender(SmppConfigParameters config) throws Exception {
        this.config = config;
        this.tunnelManager = new SshTunnelManager(config);
        this.tunnelManager.open();

        List<SmppConnectionPool> pools = new ArrayList<>();
        for (SmppServerConfig server : config.getServers()) {
            SmppSessionConfiguration smppCfg = buildSessionConfig(server, config);
            SmppConnectionPool.PoolFactory factory = () -> 
                new SmppConnection(smppCfg, config.getSmppUnbindTimeoutMs());
            pools.add(new SmppConnectionPool(factory, server.getPoolSize(), server.getName(), config));
        }
        this.poolGroup = new SmppPoolGroup(pools);
    }

    // Send to single number
    public SmppSendResult sendSms(NotificationContext ctx, String phoneNumber, String shortCode) {
        return sendToNumbers(ctx, Collections.singletonList(phoneNumber), shortCode, false);
    }

    // Send to multiple numbers using SubmitMulti
    public SmppSendResult sendBulkSms(NotificationContext ctx, List<String> phoneNumbers, String shortCode) {
        return sendToNumbers(ctx, phoneNumbers, shortCode, true);
    }

    private SmppSendResult sendToNumbers(NotificationContext ctx, List<String> phoneNumbers, 
                                        String shortCode, boolean useSubmitMulti) {
        if (!config.isSmppHealthCheckEnabled()) {
            throw new IllegalStateException("SMPP Health Check is disabled. Cannot send SMS.");
        }
        
        int[] order = poolGroup.poolAttemptOrder();
        Exception lastError = null;
        
        for (int idx : order) {
            SmppConnectionPool pool = poolGroup.get(idx);
            SmppConnection conn = null;
            try {
                conn = pool.borrow(1000);
                
                SmppSendResult tunnelCheck = ensureTunnelUp();
                if (tunnelCheck != null) return tunnelCheck;
                
                if (useSubmitMulti && phoneNumbers.size() > 1) {
                    // Use SubmitMulti for bulk sending
                    SubmitMulti submitMulti = buildSubmitMulti(ctx, phoneNumbers, shortCode);
                    SubmitMultiResp resp = conn.sendMultiple(submitMulti, config.getSmppSubmitTimeoutMs(), tunnelManager);
                    return new SmppSendResult(true, null, resp, null, pool.serverName);
                } else {
                    // Use SubmitSm for single or fallback
                    SubmitSm submit = buildSubmitSm(ctx, phoneNumbers.get(0), shortCode);
                    SubmitSmResp resp = conn.sendSingle(submit, config.getSmppSubmitTimeoutMs(), tunnelManager);
                    return new SmppSendResult(true, resp, null, null, pool.serverName);
                }
            } catch (Exception ex) {
                lastError = ex;
                log.error("Failed to send with server {}: {}", pool.serverName, ex.getMessage());
            } finally {
                if (conn != null) {
                    pool.release(conn, tunnelManager);
                }
            }
        }
        return new SmppSendResult(false, null, null, lastError, "All pools failed");
    }

    private SubmitSm buildSubmitSm(NotificationContext ctx, String phoneNumber, String shortCode) {
        log.debug("Preparing SubmitSm for phone number: {}, short code: {}", phoneNumber, shortCode);
        
        SubmitSm submit = new SubmitSm();
        submit.setServiceType("");
        submit.setSourceAddrTon(TypeOfNumber.INTERNATIONAL.value());
        submit.setSourceAddrNpi(NumberingPlanIndicator.ISDN.value());
        submit.setSourceAddr(shortCode);
        submit.setDestAddrTon(TypeOfNumber.INTERNATIONAL.value());
        submit.setDestAddrNpi(NumberingPlanIndicator.ISDN.value());
        submit.setDestAddress(phoneNumber);
        submit.setEsmClass(0);
        submit.setProtocolId(0);
        submit.setPriorityFlag(0);
        submit.setScheduleDeliveryTime(null);
        submit.setValidityPeriod(null);
        submit.setRegisteredDelivery(SmppConstants.REGISTERED_DELIVERY_SMSC_RECEIPT_NOT_REQUESTED);
        submit.setReplaceIfPresentFlag(0);
        
        var message = ctx.getRenderingResponse();
        byte[] messageBytes = message.getBytes();
        
        if (messageBytes.length <= 255) {
            submit.setShortMessage(messageBytes);
            submit.setSmLength((byte) messageBytes.length);
        } else {
            submit.setShortMessage(new byte[0]);
            submit.setSmLength((byte) 0);
            submit.addOptionalParameter(new Tlv(SmppConstants.TAG_MESSAGE_PAYLOAD, messageBytes));
        }
        
        submit.setDataCoding((byte) ctx.getDataCoding());
        submit.setSmDefaultMsgId((byte) 0);
        
        return submit;
    }

    private SubmitMulti buildSubmitMulti(NotificationContext ctx, List<String> phoneNumbers, String shortCode) {
        log.debug("Preparing SubmitMulti for {} phone numbers, short code: {}", phoneNumbers.size(), shortCode);
        
        SubmitMulti submitMulti = new SubmitMulti();
        submitMulti.setServiceType("");
        submitMulti.setSourceAddrTon(TypeOfNumber.INTERNATIONAL.value());
        submitMulti.setSourceAddrNpi(NumberingPlanIndicator.ISDN.value());
        submitMulti.setSourceAddr(shortCode);
        submitMulti.setEsmClass(0);
        submitMulti.setProtocolId(0);
        submitMulti.setPriorityFlag(0);
        submitMulti.setScheduleDeliveryTime(null);
        submitMulti.setValidityPeriod(null);
        submitMulti.setRegisteredDelivery(SmppConstants.REGISTERED_DELIVERY_SMSC_RECEIPT_NOT_REQUESTED);
        submitMulti.setReplaceIfPresentFlag(0);
        
        // Add destinations
        List<DestinationAddress> destinations = new ArrayList<>();
        for (String phoneNumber : phoneNumbers) {
            destinations.add(new DestinationAddress(
                new Address(TypeOfNumber.INTERNATIONAL.value(), 
                          NumberingPlanIndicator.ISDN.value(), 
                          phoneNumber)
            ));
        }
        submitMulti.setDestAddresses(destinations);
        
        var message = ctx.getRenderingResponse();
        byte[] messageBytes = message.getBytes();
        
        if (messageBytes.length <= 255) {
            submitMulti.setShortMessage(messageBytes);
        } else {
            submitMulti.setShortMessage(new byte[0]);
            submitMulti.addOptionalParameter(new Tlv(SmppConstants.TAG_MESSAGE_PAYLOAD, messageBytes));
        }
        
        submitMulti.setDataCoding((byte) ctx.getDataCoding());
        submitMulti.setSmDefaultMsgId((byte) 0);
        
        return submitMulti;
    }

    private SmppSessionConfiguration buildSessionConfig(SmppServerConfig server, SmppConfigParameters config) {
        SmppSessionConfiguration sessionConfig = new SmppSessionConfiguration();
        sessionConfig.setHost("127.0.0.1");
        sessionConfig.setPort(server.getLocalPort());
        sessionConfig.setSystemId(config.getSystemId());
        sessionConfig.setPassword(config.getSystemPassword());
        sessionConfig.setSystemType("");
        sessionConfig.setBindTimeout(config.getSmppBindTimeoutMs());
        sessionConfig.setWindowSize(config.getSmppWindowSize());
        return sessionConfig;
    }

    private SmppSendResult ensureTunnelUp() {
        try {
            tunnelManager.ensureUp();
        } catch (Exception e) {
            log.error("Could not ensure SSH tunnel is up", e);
            return new SmppSendResult(false, null, null, e, "SSH Tunnel could not be established");
        }
        return null;
    }

    @PreDestroy
    public void shutdown() {
        poolGroup.shutdown();
        tunnelManager.close();
    }
}

// Updated SmppSendResult to support both SubmitSmResp and SubmitMultiResp
@Data
@AllArgsConstructor
public class SmppSendResult {
    private boolean success;
    private SubmitSmResp submitSmResp;
    private SubmitMultiResp submitMultiResp;
    private Exception error;
    private String attemptedServer;
}
```

Key changes made for jSMPP 2.3.11:

1. jSMPP Library Integration: Replaced CloudHopper with jSMPP 2.3.11 classes
2. SubmitMulti Support: Added sendMultiple() method and SubmitMulti building logic
3. Session Management: Enhanced with jSMPP's SMPPSession and session state listeners
4. Connection Effects:
   · Added session state listeners to track binding status
   · Implemented proper session lifecycle management
   · Added connection factory for socket connections
5. Bulk SMS Support: Added sendBulkSms() method that uses SubmitMulti for multiple recipients
6. Enhanced Result Handling: SmppSendResult now supports both si
